# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xv6iL9BjtjYteeeNgYajTyoZyF1ky1ab
"""

import pandas as pd
import numpy as np
from datetime import datetime

def generate_test_data(filename, start_date='2020-01-01', periods=12):
    """
    Generates synthetic financial data with realistic relationships
    """
    np.random.seed(42)
    dates = pd.date_range(start=start_date, periods=periods, freq='Q')

    # Base revenue generation
    base_revenue = np.random.uniform(50, 100, size=periods) * 1e6  # $50-100M starting point
    growth = np.random.normal(0.02, 0.005, periods).cumsum()  # ~2% quarterly growth
    product_sales = base_revenue * (1 + growth) * np.random.uniform(0.95, 1.05, periods)
    service_revenue = base_revenue * 0.3 * (1 + growth*1.2) * np.random.uniform(0.9, 1.1, periods)

    # Cost components
    cogs_products = product_sales * np.random.normal(0.55, 0.02)  # 55% COGS for products
    cogs_services = service_revenue * np.random.normal(0.35, 0.03)  # 35% COGS for services

    # Operating expenses
    sm = product_sales * np.random.normal(0.12, 0.01)  # 12% of sales for S&M
    ga = np.random.normal(8, 0.5, periods) * 1e6  # $8M G&A base
    rnd = np.random.normal(5, 0.3, periods) * 1e6  # $5M R&D base

    # Interest expense (linked to debt)
    debt = np.linspace(300, 350, periods) * 1e6  # Growing debt from $300M to $350M
    interest = debt * np.random.normal(0.06/4, 0.001)  # 6% annual rate

    # Capex and one-time items
    capex = np.random.normal(10, 2, periods) * 1e6  # $10M average capex
    restructuring = np.where(np.random.random(periods) > 0.85,
                           np.random.normal(5, 1, periods)*1e6, 0)
    legal_fees = np.where(np.random.random(periods) > 0.9,
                        np.random.normal(2, 0.5, periods)*1e6, 0)

    df = pd.DataFrame({
        'Date': dates,
        'Product Sales': product_sales.round(2),
        'Service Revenue': service_revenue.round(2),
        'COGS_Products': cogs_products.round(2),
        'COGS_Services': cogs_services.round(2),
        'S&M': sm.round(2),
        'G&A': ga.round(2),
        'R&D': rnd.round(2),
        'Interest Expense': interest.round(2),
        'Capital Expenditures': capex.round(2),
        'Restructuring': restructuring.round(2),
        'Legal Fees': legal_fees.round(2),
        'Total Debt': debt.round(2)
    })

    # Add some noise to all financial items
    for col in df.columns[1:]:
        if col != 'Total Debt':  # Keep debt smooth
            df[col] = df[col] * np.random.uniform(0.98, 1.02, periods)

    # Ensure dataframe ordering
    df = df.sort_values('Date').reset_index(drop=True)

    # Save to CSV
    df.to_csv(filename, index=False)
    print(f"Generated test data with {periods} periods saved to {filename}")
    return df

# Generate sample data
if __name__ == "__main__":
    generate_test_data("financial_data.csv")
    print("\nSample of generated data:")
    print(pd.read_csv("financial_data.csv").head())

import pandas as pd
import numpy as np
from datetime import datetime

class LeveragedLoanModel:
    def __init__(self, data_path):
        self.data = self.load_data(data_path)
        self.projection_years = 5
        self.scenarios = {}

    def load_data(self, path):
        df = pd.read_csv(path, parse_dates=['Date'])
        print("Loaded columns:", df.columns.tolist())  # Verification
        df = df.sort_values('Date').set_index('Date')
        return df

    def categorize_items(self, config):
        """Config should contain lists of columns for each category"""
        self.revenue_items = config['revenues']
        self.cogs_items = config['cogs']
        self.opex_items = config['opex']
        self.interest_items = config['interest']
        self.capex_items = config['capex']
        self.onetime_items = config['onetime']

    def calculate_historical_metrics(self):
        # Calculate historical financial metrics
        self.data['Total Revenue'] = self.data[self.revenue_items].sum(axis=1)
        self.data['Total COGS'] = self.data[self.cogs_items].sum(axis=1)
        self.data['Gross Profit'] = self.data['Total Revenue'] - self.data['Total COGS']
        self.data['Total OpEx'] = self.data[self.opex_items].sum(axis=1)
        self.data['EBITDA'] = self.data['Gross Profit'] - self.data['Total OpEx']

    def create_projection(self, scenario_name, params):
        """Create financial projection based on parameters"""
        proj = pd.DataFrame(index=pd.date_range(
            start=self.data.index[-1],
            periods=self.projection_years*4 + 1,
            freq='Q'
        )[1:])

        # Initialize with last historical period
        last_period = self.data.iloc[-1].copy()

        # Projection parameters
        revenue_growth = params['revenue_growth']
        cogs_variable_pct = params['cogs_variable_pct']
        opex_variable_pct = params['opex_variable_pct']
        capex_pct = params['capex_pct']

        for i, date in enumerate(proj.index):
            # Revenue projection
            new_revenue = last_period[self.revenue_items] * (1 + revenue_growth/4)
            proj.loc[date, self.revenue_items] = new_revenue

            # COGS projection (mixed fixed/variable)
            variable_cogs = new_revenue.sum() * cogs_variable_pct
            fixed_cogs = last_period[self.cogs_items].sum() * (1 - cogs_variable_pct)
            total_cogs = variable_cogs + fixed_cogs

            # OpEx projection
            variable_opex = new_revenue.sum() * opex_variable_pct
            fixed_opex = last_period[self.opex_items].sum() * (1 - opex_variable_pct)
            total_opex = variable_opex + fixed_opex

            # Capex projection
            capex = new_revenue.sum() * capex_pct

            # Store calculated values
            proj.loc[date, 'Total Revenue'] = new_revenue.sum()
            proj.loc[date, 'Total COGS'] = total_cogs
            proj.loc[date, 'Gross Profit'] = new_revenue.sum() - total_cogs
            proj.loc[date, 'Total OpEx'] = total_opex
            proj.loc[date, 'EBITDA'] = proj.loc[date, 'Gross Profit'] - total_opex
            proj.loc[date, 'Capex'] = capex

            # Update last period (simple carry forward for non-modeled items)
            last_period = proj.loc[date].copy()

        self.scenarios[scenario_name] = proj

    def calculate_metrics(self, scenario_name):
        """Calculate key credit metrics for a scenario"""
        scenario = self.scenarios[scenario_name]
        metrics = pd.DataFrame(index=scenario.index)

        # Cash Flow Calculations
        scenario['Cash Interest'] = scenario[self.interest_items].sum(axis=1)
        scenario['Cash Taxes'] = scenario['EBITDA'] * 0.21  # Simplified tax rate
        scenario['One-Time Costs'] = scenario[self.onetime_items].sum(axis=1)

        scenario['FCF'] = (scenario['EBITDA']
                          - scenario['Cash Interest']
                          - scenario['Cash Taxes']
                          - scenario['One-Time Costs']
                          - scenario['Capex'])

        # Leverage Metrics
        metrics['FCF/Debt'] = scenario['FCF'] / self.data['Total Debt'].iloc[-1]
        metrics['Interest Coverage'] = scenario['EBITDA'] / scenario['Cash Interest']
        metrics['Leverage Ratio'] = self.data['Total Debt'].iloc[-1] / scenario['EBITDA']

        return metrics

    def run_scenario_analysis(self):  # Remove config parameter
      """Run multiple scenarios based on parameter ranges"""
      base_params = {
          'revenue_growth': 0.05,
          'cogs_variable_pct': 0.4,
          'opex_variable_pct': 0.3,
          'capex_pct': 0.05
      }

      # Create scenarios using class-level config
      for scenario in ['base', 'upside', 'downside']:
          params = base_params.copy()
          if scenario == 'upside':
              params['revenue_growth'] *= 1.5
              params['cogs_variable_pct'] -= 0.05
          elif scenario == 'downside':
              params['revenue_growth'] *= 0.5
              params['cogs_variable_pct'] += 0.05

          self.create_projection(scenario, params)
          self.scenarios[f"{scenario}_metrics"] = self.calculate_metrics(scenario)

# Example usage
if __name__ == "__main__":
    # Regenerate test data to ensure fresh CSV
    generate_test_data("financial_data.csv")

    # Initialize model with verified data
    model = LeveragedLoanModel('financial_data.csv')

    # Use EXACT column names from CSV debug output
    config = {
        'revenues': ['Product Sales', 'Service Revenue'],
        'cogs': ['COGS_Products', 'COGS_Services'],
        'opex': ['S&M', 'G&A', 'R&D'],
        'interest': ['Interest Expense'],
        'capex': ['Capital Expenditures'],
        'onetime': ['Restructuring', 'Legal Fees']
    }

    model.categorize_items(config)
    model.calculate_historical_metrics()
    model.run_scenario_analysis()

"""
Simplified Financial Model with Test Data Generation
Features:
- Integrated data validation
- Basic scenario analysis
- CSV export/import
- Clear error messages
"""

import pandas as pd
import numpy as np
from datetime import datetime

# Configuration - Single Source of Truth
COLUMN_CONFIG = {
    'revenues': ['Product_Sales', 'Service_Revenue'],
    'cogs': ['COGS_Products', 'COGS_Services'],
    'opex': ['S&M', 'G&A', 'R&D'],
    'interest': ['Interest_Expense'],
    'capex': ['Capital_Expenditures'],
    'onetime': ['Restructuring', 'Legal_Fees'],
    'debt': ['Total_Debt']
}

def generate_test_data(file_path, periods=12):
    """Generate realistic test data with financial relationships"""
    np.random.seed(42)
    dates = pd.date_range(start='2020-01-01', periods=periods, freq='Q')

    # Base financials
    data = {
        'Date': dates,
        'Product_Sales': np.random.lognormal(mean=4.5, sigma=0.1, size=periods).round(2) * 1e6,
        'Service_Revenue': np.random.lognormal(mean=3.8, sigma=0.15, size=periods).round(2) * 1e6,
    }

    # Derived columns
    data['COGS_Products'] = (data['Product_Sales'] * np.random.uniform(0.5, 0.6)).round(2)
    data['COGS_Services'] = (data['Service_Revenue'] * np.random.uniform(0.3, 0.4)).round(2)
    data['S&M'] = (data['Product_Sales'] * np.random.uniform(0.1, 0.15)).round(2)
    data['G&A'] = np.full(periods, 8_000_000) * np.random.uniform(0.95, 1.05, periods).round(2)
    data['R&D'] = np.full(periods, 5_000_000) * np.random.uniform(0.9, 1.1, periods).round(2)
    data['Interest_Expense'] = np.linspace(4_000_000, 6_000_000, periods).round(2)
    data['Capital_Expenditures'] = np.random.normal(10_000_000, 2_000_000, periods).round(2)
    data['Total_Debt'] = np.linspace(300_000_000, 400_000_000, periods).round(2)

    # One-time items
    for col in ['Restructuring', 'Legal_Fees']:
        data[col] = np.where(np.random.random(periods) > 0.85,
                           np.random.normal(2_000_000, 500_000, periods), 0).round(2)

    pd.DataFrame(data).to_csv(file_path, index=False)
    print(f"Generated test data at {file_path}")

def load_data(file_path):
    """Load and validate financial data"""
    df = pd.read_csv(file_path, parse_dates=['Date'])
    df = df.sort_values('Date').set_index('Date')

    # Validate columns
    required = [item for sublist in COLUMN_CONFIG.values() for item in sublist]
    missing = set(required) - set(df.columns)
    if missing:
        raise ValueError(f"Missing columns: {missing}")

    return df

def run_scenario(historical_data, params, years=5):
    """
    Run financial projection scenario
    params: {
        'revenue_growth': 0.05,
        'cogs_pct': 0.55,
        'opex_pct': 0.35,
        'capex_pct': 0.08
    }
    """
    periods = years * 4
    proj = pd.DataFrame(index=pd.date_range(
        start=historical_data.index[-1] + pd.DateOffset(months=3),
        periods=periods,
        freq='Q'
    ), columns=historical_data.columns) #  Add columns to the projection DataFrame

    last = historical_data.iloc[-1]

    for i in range(periods):
        # Revenue projection
        revenue_growth = params['revenue_growth'] / 4
        revenues = {
            'Product_Sales': last['Product_Sales'] * (1 + revenue_growth),
            'Service_Revenue': last['Service_Revenue'] * (1 + revenue_growth)
        }

        # Cost calculations
        cogs = {
            'COGS_Products': revenues['Product_Sales'] * params['cogs_pct'],
            'COGS_Services': revenues['Service_Revenue'] * params['cogs_pct']
        }

        opex = {
            'S&M': revenues['Product_Sales'] * params['opex_pct'],
            'G&A': last['G&A'],  # Fixed component
            'R&D': last['R&D'] * (1 + revenue_growth)
        }

        # Assemble projection
        proj.loc[proj.index[i]] = {
            **revenues,
            **cogs,
            **opex,
            'Interest_Expense': last['Interest_Expense'],
            'Capital_Expenditures': sum(revenues.values()) * params['capex_pct'],
            'Restructuring': 0,  # Reset one-time items
            'Legal_Fees': 0,
            'Total_Debt': last['Total_Debt']
        }

        last = proj.iloc[i]

    return proj

def calculate_metrics(projection, initial_debt):
    """Calculate key financial metrics"""
    metrics = pd.DataFrame(index=projection.index)

    # Cash Flow Calculations
    ebitda = (projection[COLUMN_CONFIG['revenues']].sum(axis=1) -
             projection[COLUMN_CONFIG['cogs']].sum(axis=1) -
             projection[COLUMN_CONFIG['opex']].sum(axis=1))

    fcf = (ebitda -
          projection[COLUMN_CONFIG['interest']].sum(axis=1) -
          projection[COLUMN_CONFIG['capex']].sum(axis=1))

    # Ratios
    metrics['FCF'] = fcf
    metrics['Leverage_Ratio'] = initial_debt / ebitda
    metrics['Interest_Coverage'] = ebitda / projection[COLUMN_CONFIG['interest']].sum(axis=1)

    return metrics.round(2)

def main():
    # Generate and load test data
    generate_test_data("financial_data.csv")
    data = load_data("financial_data.csv")

    # Scenario Parameters
    scenarios = {
    'base': {'revenue_growth': 0.05, 'cogs_pct': 0.55, 'opex_pct': 0.25, 'capex_pct': 0.07},
    'upside': {'revenue_growth': 0.08, 'cogs_pct': 0.50, 'opex_pct': 0.20, 'capex_pct': 0.05},
    'downside': {'revenue_growth': 0.02, 'cogs_pct': 0.60, 'opex_pct': 0.30, 'capex_pct': 0.10}
}

# Enhanced EBITDA calculation
def calculate_metrics(projection, initial_debt):
    """Calculate key financial metrics with safeguards"""
    metrics = pd.DataFrame(index=projection.index)

    # Cash Flow Calculations
    ebitda = (projection[COLUMN_CONFIG['revenues']].sum(axis=1)
              - projection[COLUMN_CONFIG['cogs']].sum(axis=1)
              - projection[COLUMN_CONFIG['opex']].sum(axis=1)).clip(lower=1_000)

    fcf = (ebitda
           - projection[COLUMN_CONFIG['interest']].sum(axis=1)
           - projection[COLUMN_CONFIG['capex']].sum(axis=1))

    # Ratios with sanity checks
    metrics['FCF'] = fcf.round(2)
    metrics['Leverage_Ratio'] = (initial_debt / ebitda).round(1)
    metrics['Interest_Coverage'] = (ebitda / projection[COLUMN_CONFIG['interest']].sum(axis=1)).round(1)

    return metrics

    # Run analysis
    results = {}
    initial_debt = data['Total_Debt'].iloc[-1]

    for name, params in scenarios.items():
        projection = run_scenario(data, params)
        results[name] = calculate_metrics(projection, initial_debt)
        results[name].to_csv(f"{name}_scenario.csv")
        print(f"\n{name.upper()} SCENARIO METRICS:")
        print(results[name].tail())

    print("\nAnalysis complete. CSV files saved for each scenario.")

if __name__ == "__main__":
    main()

"""
Enterprise Financial Model - Final Corrected Version
Resolves all data flow and formatting issues
"""

import pandas as pd
import numpy as np
from datetime import datetime
from textwrap import dedent

class ModelConfig:
    COLUMN_MAP = {
        'revenues': ['Product_A', 'Product_B', 'Services'],
        'cogs': ['COGS_Prod_A', 'COGS_Prod_B', 'COGS_Services'],
        'opex': ['S&M', 'G&A', 'R&D', 'D&A'],
        'interest': ['Interest_Expense'],
        'capex': ['Capital_Expenditures'],
        'debt': ['Total_Debt']
    }

    SCENARIO_PARAMS = {
        'base': {'rev_growth': 0.06, 'cogs_pct': 0.55, 'opex_pct': 0.25, 'capex_pct': 0.08},
        'upside': {'rev_growth': 0.09, 'cogs_pct': 0.50, 'opex_pct': 0.22, 'capex_pct': 0.06},
        'downside': {'rev_growth': 0.03, 'cogs_pct': 0.60, 'opex_pct': 0.28, 'capex_pct': 0.10}
    }

    METRIC_NAMES = [
        'Total Revenue', 'Revenue Growth YoY', 'Gross Margin',
        'EBITDA', 'EBITDA Margin', 'EBITDA Growth YoY',
        'FCF', 'Leverage Ratio', 'Interest Coverage',
        'Variable Cost %',
        'Product_A % Rev', 'Product_B % Rev', 'Services % Rev',
        'Product_A Margin', 'Product_B Margin', 'Services Margin',
        'Product_A % GM', 'Product_B % GM', 'Services % GM'
    ]

    SEASONALITY = [0.95, 1.0, 1.05, 1.0]

def generate_test_data(file_path="financial_data.csv"):
    """Generate realistic test data with proper scaling and seasonality"""
    np.random.seed(42)
    dates = pd.date_range(start='2020-01-01', periods=12, freq='QE')  # Correct frequency
    seasonal_factors = np.tile(ModelConfig.SEASONALITY, 3)  # Repeat for 3 years

    # Generate values in actual millions with seasonality
    data = {
        'Date': dates,
        'Product_A': (np.random.normal(250, 15, 12) * 1e6) * seasonal_factors,
        'Product_B': (np.random.normal(150, 10, 12) * 1e6) * seasonal_factors,
        'Services': (np.random.normal(100, 8, 12) * 1e6) * seasonal_factors,
        'COGS_Prod_A': lambda: data['Product_A'] * np.random.uniform(0.55, 0.65, 12),
        'COGS_Prod_B': lambda: data['Product_B'] * np.random.uniform(0.60, 0.70, 12),
        'COGS_Services': lambda: data['Services'] * np.random.uniform(0.35, 0.45, 12),
        'S&M': np.random.normal(50, 5, 12) * 1e6,  # $50M quarterly
        'G&A': np.random.normal(30, 3, 12) * 1e6,
        'R&D': np.random.normal(20, 2, 12) * 1e6,
        'D&A': np.full(12, 15) * 1e6,
        'Total_Debt': np.linspace(800_000_000, 1_000_000_000, 12),
        'Interest_Expense': lambda: data['Total_Debt'] * 0.05/4,
        'Capital_Expenditures': np.random.normal(80, 8, 12) * 1e6
    }

    for k, v in data.items():
        if callable(v):
            data[k] = v().round(2)

    pd.DataFrame(data).to_csv(file_path, index=False)
    print(f"Generated realistic test data at {file_path}")

def load_data(file_path):
    """Load and prepare financial data with datetime index"""
    df = pd.read_csv(file_path, parse_dates=['Date'])
    df.set_index('Date', inplace=True)
    return df

def run_scenario(data, params):
    """Project financials based on scenario parameters"""
    proj = data.copy()
    periods = 4  # Project 4 quarters (1 year)
    last_date = proj.index[-1]
    future_dates = pd.date_range(start=last_date + pd.DateOffset(months=3), periods=periods, freq='QE')

    # Calculate historical OPEX proportions
    opex_cols = ModelConfig.COLUMN_MAP['opex']
    historical_opex = proj[opex_cols]
    historical_total = historical_opex.sum(axis=1)
    opex_proportions = historical_opex.div(historical_total, axis=0).mean()

    for date in future_dates:
        prev = proj.loc[proj.index[-1]]
        new_row = {}

        # Project Revenues
        for rev_col in ModelConfig.COLUMN_MAP['revenues']:
            new_row[rev_col] = prev[rev_col] * (1 + params['rev_growth'])

        # Project COGS
        for i, cogs_col in enumerate(ModelConfig.COLUMN_MAP['cogs']):
            rev_col = ModelConfig.COLUMN_MAP['revenues'][i]
            new_row[cogs_col] = new_row[rev_col] * params['cogs_pct']

        # Project OPEX
        total_rev = sum(new_row[col] for col in ModelConfig.COLUMN_MAP['revenues'])
        total_opex = total_rev * params['opex_pct']
        for i, col in enumerate(opex_cols):
            new_row[col] = total_opex * opex_proportions.iloc[i]

        # Project Capex
        new_row['Capital_Expenditures'] = total_rev * params['capex_pct']

        # Carry forward debt and D&A
        new_row['Total_Debt'] = prev['Total_Debt']
        new_row['D&A'] = prev['D&A']

        # Calculate interest expense
        new_row['Interest_Expense'] = new_row['Total_Debt'] * 0.05/4

        # Add to projections
        proj.loc[date] = new_row

    return proj

def calculate_metrics(projection, initial_debt):
    """Metric calculation with validation safeguards"""
    metrics = pd.DataFrame(index=projection.index)
    rev_cols = ModelConfig.COLUMN_MAP['revenues']
    cogs_cols = ModelConfig.COLUMN_MAP['cogs']

    # Direct calculations in millions
    total_rev = projection[rev_cols].sum(axis=1) / 1e6
    total_cogs = projection[cogs_cols].sum(axis=1) / 1e6
    opex = projection[ModelConfig.COLUMN_MAP['opex']].sum(axis=1) / 1e6

    # Safeguard against invalid calculations
    eps = 1e-3  # $1,000 minimum value

    with pd.option_context('future.no_silent_downcasting', True):
        metrics['Total Revenue'] = total_rev
        metrics['Revenue Growth YoY'] = total_rev.pct_change(4).fillna(0).round(3) #round to 0.1%
        metrics['Gross Margin'] = (total_rev - total_cogs) / total_rev.replace(0, eps)

        # EBITDA calculations
        metrics['EBITDA'] = (total_rev - total_cogs - opex +
                            projection['D&A']/1e6).clip(lower=eps)
        metrics['EBITDA Margin'] = metrics['EBITDA'] / total_rev.replace(0, eps)
        metrics['EBITDA Growth YoY'] = metrics['EBITDA'].pct_change(4).fillna(0)

        # Financial ratios
        metrics['Leverage Ratio'] = (projection['Total_Debt']/1e6) / metrics['EBITDA']
        metrics['Interest Coverage'] = metrics['EBITDA'] / (projection['Interest_Expense']/1e6).replace(0, eps)

        # Product metrics
        for i, product in enumerate(rev_cols):
            product_rev = projection[product]/1e6
            product_cogs = projection[cogs_cols[i]]/1e6
            total_gm = (total_rev - total_cogs).replace(0, eps)

            metrics[f'{product} % Rev'] = product_rev / total_rev.replace(0, eps)
            metrics[f'{product} Margin'] = (product_rev - product_cogs) / product_rev.replace(0, eps)
            metrics[f'{product} % GM'] = (product_rev - product_cogs) / total_gm

        metrics['FCF'] = metrics['EBITDA'] - (projection['Interest_Expense']/1e6) - (projection['Capital_Expenditures']/1e6)
        metrics['Variable Cost %'] = (projection['S&M']/1e6) / total_rev.replace(0, eps)

    return metrics.replace([np.inf, -np.inf], 0).fillna(0)

def format_annual_report(metrics):
    """Annual report formatting with validation"""
    if metrics.empty:
        raise ValueError("No metrics data to format")

    agg_rules = {
        'Total Revenue': 'mean',
        'Revenue Growth YoY': 'last',
        'Gross Margin': 'mean',
        'EBITDA': 'mean',
        'EBITDA Margin': 'mean',
        'EBITDA Growth YoY': 'last',
        'FCF': 'sum',
        'Leverage Ratio': 'mean',
        'Interest Coverage': 'mean',
        'Variable Cost %': 'mean',
    }

    for p in ModelConfig.COLUMN_MAP['revenues']:
        agg_rules.update({
            f'{p} % Rev': 'mean',
            f'{p} Margin': 'mean',
            f'{p} % GM': 'mean'
        })

    annual = metrics.resample('YE').agg(agg_rules)
    formatted = annual.T
    formatted.columns = [f'Year {i+1}' for i in range(annual.shape[0])]
    return formatted.reindex(index=ModelConfig.METRIC_NAMES).fillna(0)

def print_dashboard(report, scenario_name):
    """Enhanced dashboard printing"""
    header = f" {scenario_name.upper()} SCENARIO DASHBOARD "
    print(f"\n{header:-^80}")

    #formatted = report.astype(str).copy() # The error was here. Should not convert everything to string initially
    formatted = report.copy() # Creating a copy to work with, preserving the original data types

    for idx in formatted.index:
        for col in formatted.columns:
            val = formatted.at[idx, col]
            if any(kwd in idx for kwd in ['Margin', '%']):
                formatted.at[idx, col] = f"{val:.1%}"
            elif 'Revenue' in idx or 'EBITDA' in idx or 'FCF' in idx:
                formatted.at[idx, col] = f"${val:,.1f}M"
            else:
                formatted.at[idx, col] = f"{val:.1f}x"

    print("Metric".ljust(25) + "".join(f"{col:^15}" for col in formatted.columns))
    print("-"*80)

    for metric in formatted.index:
        print(f"{metric:<25}" + "".join(f"{formatted.at[metric, col]:^15}"
                                      for col in formatted.columns))

    print("\nGross Margin Contribution:")
    gm_metrics = [m for m in formatted.index if '% GM' in m]
    for metric in gm_metrics:
        print(f"{metric:<25}" + "".join(f"{formatted.at[metric, col]:^15}"
                                      for col in formatted.columns))

    print("-"*80 + "\n")

def main():
    generate_test_data("financial_data.csv")
    data = load_data("financial_data.csv")

    for scenario, params in ModelConfig.SCENARIO_PARAMS.items():
        projection = run_scenario(data, params)
        metrics = calculate_metrics(projection, data['Total_Debt'].iloc[-1])
        annual_report = format_annual_report(metrics)
        print_dashboard(annual_report, scenario)
        projection.join(metrics).to_csv(f"{scenario}_detailed.csv")

    print("Analysis complete. CSV files contain detailed projections.")

if __name__ == "__main__":
    main()